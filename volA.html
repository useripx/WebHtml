<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emotional Volume Controller - Pengatur Volume Aneh</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;700;900&display=swap');
        
        body {
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
        }
        
        .volume-orb {
            width: 300px;
            height: 300px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.8), transparent);
            box-shadow: 0 0 60px currentColor, inset 0 0 60px currentColor;
            animation: pulse-orb 2s ease-in-out infinite;
            transition: all 0.3s ease;
        }
        
        @keyframes pulse-orb {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .draw-canvas {
            border: 3px dashed rgba(255,255,255,0.3);
            cursor: crosshair;
            background: rgba(0,0,0,0.2);
        }
        
        .gesture-area {
            border: 3px solid rgba(255,255,255,0.2);
            background: linear-gradient(135deg, rgba(255,255,255,0.05), rgba(255,255,255,0.15));
        }
        
        .color-picker-custom {
            width: 100%;
            height: 200px;
            background: linear-gradient(to right, 
                rgb(255,0,0), 
                rgb(255,255,0), 
                rgb(0,255,0), 
                rgb(0,255,255), 
                rgb(0,0,255), 
                rgb(255,0,255), 
                rgb(255,0,0)
            );
            cursor: crosshair;
            border-radius: 12px;
        }
        
        .wave-visualizer {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 100px;
            background: linear-gradient(to top, rgba(255,255,255,0.1), transparent);
        }
        
        .neon-glow {
            text-shadow: 0 0 10px currentColor, 0 0 20px currentColor, 0 0 40px currentColor, 0 0 80px currentColor;
        }
        
        .glass-card {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }
        
        @keyframes ripple {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(4);
                opacity: 0;
            }
        }
        
        .ripple {
            position: absolute;
            border-radius: 50%;
            border: 2px solid white;
            animation: ripple 1s ease-out;
        }
        
        .shake {
            animation: shake 0.5s ease-in-out;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }
        
        .rotate-3d {
            transform-style: preserve-3d;
            transition: transform 0.5s;
        }
        
        .pattern-bg {
            background-image: 
                repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(255,255,255,.03) 10px, rgba(255,255,255,.03) 20px);
        }
    </style>
</head>
<body class="bg-gradient-to-br from-purple-900 via-indigo-900 to-blue-900 pattern-bg">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const EmotionalVolumeController = () => {
            const [volume, setVolume] = useState(50);
            const [controlMode, setControlMode] = useState('draw');
            const [isListening, setIsListening] = useState(false);
            const [mouseTrail, setMouseTrail] = useState([]);
            const [ripples, setRipples] = useState([]);
            const [shapeComplexity, setShapeComplexity] = useState(0);
            const [currentColor, setCurrentColor] = useState('#8B5CF6');
            const [audioContext, setAudioContext] = useState(null);
            const [oscillator, setOscillator] = useState(null);
            const [gainNode, setGainNode] = useState(null);
            
            const canvasRef = useRef(null);
            const gestureRef = useRef(null);
            const isDrawing = useRef(false);
            const drawPoints = useRef([]);

            const controlModes = [
                { 
                    id: 'draw', 
                    name: 'Gambar Bentuk', 
                    icon: 'âœï¸',
                    description: 'Gambar bentuk rumit = volume tinggi',
                    instruction: 'Gambar di canvas! Semakin rumit, semakin keras!'
                },
                { 
                    id: 'gesture', 
                    name: 'Gerakan Mouse', 
                    icon: 'ðŸ–±ï¸',
                    description: 'Gerakkan mouse dengan pola',
                    instruction: 'Gerakkan mouse dalam kotak! Kecepatan = volume!'
                },
                { 
                    id: 'color', 
                    name: 'Warna Emosi', 
                    icon: 'ðŸŽ¨',
                    description: 'Pilih warna untuk mengatur volume',
                    instruction: 'Merah = Keras, Biru = Pelan, Hijau = Sedang'
                },
                { 
                    id: 'voice', 
                    name: 'Berteriak', 
                    icon: 'ðŸ—£ï¸',
                    description: 'Semakin keras teriak, semakin keras volume',
                    instruction: 'Klik "Dengar" dan berteriak! (Butuh mic)'
                },
                { 
                    id: 'shake', 
                    name: 'Goyang Device', 
                    icon: 'ðŸ“±',
                    description: 'Goyang device untuk mengubah volume',
                    instruction: 'Goyang HP atau goyangkan mouse!'
                },
                { 
                    id: 'spiral', 
                    name: 'Spiral Hypnotic', 
                    icon: 'ðŸŒ€',
                    description: 'Ikuti spiral dengan mouse',
                    instruction: 'Ikuti lingkaran! Makin cepat = makin keras!'
                }
            ];

            const mode = controlModes.find(m => m.id === controlMode);

            // Initialize Audio
            useEffect(() => {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(440, ctx.currentTime);
                osc.connect(gain);
                gain.connect(ctx.destination);
                gain.gain.setValueAtTime(0, ctx.currentTime);
                osc.start();
                
                setAudioContext(ctx);
                setOscillator(osc);
                setGainNode(gain);
                
                return () => {
                    osc.stop();
                    ctx.close();
                };
            }, []);

            // Update Audio Volume
            useEffect(() => {
                if (gainNode && audioContext) {
                    gainNode.gain.setValueAtTime(volume / 200, audioContext.currentTime);
                }
            }, [volume, gainNode, audioContext]);

            // Drawing Mode
            const startDrawing = (e) => {
                if (controlMode !== 'draw') return;
                isDrawing.current = true;
                const rect = canvasRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                drawPoints.current = [{ x, y }];
            };

            const draw = (e) => {
                if (!isDrawing.current || controlMode !== 'draw') return;
                
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                drawPoints.current.push({ x, y });
                
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(drawPoints.current[drawPoints.current.length - 2].x, 
                          drawPoints.current[drawPoints.current.length - 2].y);
                ctx.lineTo(x, y);
                ctx.stroke();
                
                // Calculate complexity
                const complexity = Math.min(100, drawPoints.current.length / 5);
                setShapeComplexity(complexity);
                setVolume(Math.round(complexity));
            };

            const stopDrawing = () => {
                isDrawing.current = false;
            };

            const clearCanvas = () => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawPoints.current = [];
                setShapeComplexity(0);
            };

            // Gesture Mode
            const handleGestureMove = (e) => {
                if (controlMode !== 'gesture') return;
                
                const rect = gestureRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                setMouseTrail(prev => {
                    const newTrail = [...prev, { x, y, time: Date.now() }];
                    return newTrail.slice(-20);
                });
                
                // Calculate speed
                if (mouseTrail.length > 5) {
                    const recentPoints = mouseTrail.slice(-5);
                    let totalDistance = 0;
                    for (let i = 1; i < recentPoints.length; i++) {
                        const dx = recentPoints[i].x - recentPoints[i-1].x;
                        const dy = recentPoints[i].y - recentPoints[i-1].y;
                        totalDistance += Math.sqrt(dx * dx + dy * dy);
                    }
                    const speed = Math.min(100, totalDistance / 2);
                    setVolume(Math.round(speed));
                }
            };

            // Color Mode
            const handleColorClick = (e) => {
                if (controlMode !== 'color') return;
                
                const rect = e.currentTarget.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const width = rect.width;
                const hue = (x / width) * 360;
                
                // Map hue to volume
                // Red (0Â°) = 100%, Green (120Â°) = 50%, Blue (240Â°) = 20%
                let vol;
                if (hue < 60) { // Red to Yellow
                    vol = 80 + (hue / 60) * 20;
                } else if (hue < 180) { // Yellow to Cyan
                    vol = 100 - ((hue - 60) / 120) * 50;
                } else { // Cyan to Magenta
                    vol = 50 - ((hue - 180) / 180) * 30;
                }
                
                setVolume(Math.round(vol));
                setCurrentColor(`hsl(${hue}, 70%, 60%)`);
                
                addRipple(e.clientX, e.clientY);
            };

            // Voice Mode
            const startListening = async () => {
                if (controlMode !== 'voice') return;
                
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const audioContext = new AudioContext();
                    const analyser = audioContext.createAnalyser();
                    const microphone = audioContext.createMediaStreamSource(stream);
                    const scriptProcessor = audioContext.createScriptProcessor(2048, 1, 1);

                    analyser.smoothingTimeConstant = 0.8;
                    analyser.fftSize = 1024;

                    microphone.connect(analyser);
                    analyser.connect(scriptProcessor);
                    scriptProcessor.connect(audioContext.destination);
                    
                    setIsListening(true);

                    scriptProcessor.onaudioprocess = () => {
                        const array = new Uint8Array(analyser.frequencyBinCount);
                        analyser.getByteFrequencyData(array);
                        const average = array.reduce((a, b) => a + b) / array.length;
                        const vol = Math.min(100, average * 2);
                        setVolume(Math.round(vol));
                    };

                    setTimeout(() => {
                        stream.getTracks().forEach(track => track.stop());
                        setIsListening(false);
                    }, 10000);
                } catch (err) {
                    alert('Microphone tidak dapat diakses!');
                }
            };

            // Shake Mode
            useEffect(() => {
                if (controlMode !== 'shake') return;

                let lastX = 0, lastY = 0, lastTime = Date.now();

                const handleShake = (e) => {
                    const currentTime = Date.now();
                    const timeDiff = currentTime - lastTime;
                    
                    if (timeDiff > 100) {
                        const diffX = Math.abs(e.clientX - lastX);
                        const diffY = Math.abs(e.clientY - lastY);
                        const speed = (diffX + diffY) / timeDiff * 100;
                        
                        setVolume(prev => {
                            const newVol = prev + speed;
                            return Math.min(100, Math.max(0, newVol));
                        });
                        
                        lastX = e.clientX;
                        lastY = e.clientY;
                        lastTime = currentTime;
                    }
                };

                window.addEventListener('mousemove', handleShake);
                return () => window.removeEventListener('mousemove', handleShake);
            }, [controlMode]);

            // Spiral Mode
            const [spiralAngle, setSpiralAngle] = useState(0);
            
            useEffect(() => {
                if (controlMode !== 'spiral') return;
                
                const handleSpiralMove = (e) => {
                    const centerX = window.innerWidth / 2;
                    const centerY = window.innerHeight / 2;
                    const angle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                    const distance = Math.sqrt(
                        Math.pow(e.clientX - centerX, 2) + 
                        Math.pow(e.clientY - centerY, 2)
                    );
                    
                    setSpiralAngle(angle);
                    const vol = Math.min(100, distance / 3);
                    setVolume(Math.round(vol));
                };
                
                window.addEventListener('mousemove', handleSpiralMove);
                return () => window.removeEventListener('mousemove', handleSpiralMove);
            }, [controlMode]);

            const addRipple = (x, y) => {
                const newRipple = { id: Date.now(), x, y };
                setRipples(prev => [...prev, newRipple]);
                setTimeout(() => {
                    setRipples(prev => prev.filter(r => r.id !== newRipple.id));
                }, 1000);
            };

            const getVolumeColor = () => {
                if (volume > 80) return '#EF4444';
                if (volume > 60) return '#F59E0B';
                if (volume > 40) return '#10B981';
                if (volume > 20) return '#3B82F6';
                return '#6366F1';
            };

            return (
                <div className="relative w-screen h-screen overflow-hidden">
                    {/* Ripples */}
                    {ripples.map(ripple => (
                        <div
                            key={ripple.id}
                            className="ripple"
                            style={{
                                left: ripple.x - 25,
                                top: ripple.y - 25,
                                width: 50,
                                height: 50
                            }}
                        />
                    ))}

                    {/* Main Content */}
                    <div className="relative z-10 h-full flex flex-col items-center justify-center p-8">
                        {/* Volume Orb */}
                        <div className="mb-8">
                            <div 
                                className="volume-orb mx-auto"
                                style={{ 
                                    color: getVolumeColor(),
                                    transform: `scale(${0.7 + (volume / 100) * 0.6})`
                                }}
                            >
                                <div className="w-full h-full flex items-center justify-center">
                                    <div className="text-center">
                                        <div className="text-7xl font-black neon-glow" style={{ color: getVolumeColor() }}>
                                            {volume}%
                                        </div>
                                        <div className="text-xl text-white mt-2 opacity-80">
                                            {volume > 80 ? 'ðŸ”Š KERAS!' : volume > 40 ? 'ðŸ”‰ Sedang' : 'ðŸ”ˆ Pelan'}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        {/* Control Modes */}
                        <div className="glass-card rounded-3xl p-6 max-w-6xl w-full mb-6">
                            <div className="grid grid-cols-6 gap-3 mb-6">
                                {controlModes.map(m => (
                                    <button
                                        key={m.id}
                                        onClick={() => {
                                            setControlMode(m.id);
                                            clearCanvas();
                                            setVolume(50);
                                        }}
                                        className={`glass-card rounded-xl p-4 transition-all transform hover:scale-105 ${
                                            controlMode === m.id ? 'ring-4 ring-white scale-105' : ''
                                        }`}
                                    >
                                        <div className="text-3xl mb-2">{m.icon}</div>
                                        <div className="text-white text-xs font-semibold">{m.name}</div>
                                    </button>
                                ))}
                            </div>

                            <div className="text-center text-white mb-4">
                                <h2 className="text-2xl font-bold mb-2">{mode.icon} {mode.name}</h2>
                                